# 葫芦娃与妖怪大混战  
作者：贾亦真 南京大学  
学号：141160024
</b>
## 界面说明

游戏的各个界面（状态 / 模式）用枚举常量标志，并在界面上有相应的文字显示。
 `enum STATE { START, PLAYING, ENDED, REPLAY, REPLAYENDED};`  
按键空格、L、R可分别开启混战状态、回放状态、初始状态，Esc用于退出游戏。不同状态下，可使用的按键不同。

- 初始状态（开始界面）   
`START` 葫芦娃与妖精在初始状态下，各自按阵型排好。  
此时，空格键开始游戏，L键读取存档。
![](https://i.imgur.com/SqicLkD.jpg)

- 混战状态（游戏界面）  
`PLAYING` 葫芦娃与妖精按规则进行战斗。  
此时，R键可以强制停止战斗，重新开始。
![](https://i.imgur.com/NgA5XL4.jpg)

- 回放状态（回放界面）   
`REPLAY` 成功读取存档后，回放游戏记录。
此进程一边读取记录，一边播放动画；若发现游戏记录有错误（格式错误），此时玩家可以选择回到初始界面，重新开始，或者以当前局面为基础，计入自由混战状态。
![](https://i.imgur.com/Rm0gPLA.jpg)

- 结束状态（结束界面）  
`ENDED` 葫芦娃与妖精混战结束后，进入混战结束界面  
`REPLAYENDED` 回放记录结束后，进入回放结束界面
此时，R键重新开始，Esc键退出游戏。
![](https://i.imgur.com/ZJfFfCS.jpg)



## 游戏策略
### 战斗设定
`Battle（Creature another）`函数控制战斗。

- 基础属性  
各个物种分别有固定的基础武力值`attack`和基础速度`speed`。 

- 加成经验  
一次战斗发生时，生物会在本身武力值的基础上，随机获得一定的加成，加成+武力值高的一方获得胜利，并且会将加成转换为经验值，直接提升存活者的攻击值。

- 速度、生命与战斗力  
基于“加成经验”设定，某生物速度越快，经历战斗越多，存活时间越长，其战斗力越高，也就更加有可能成为中级大Boss。
在本游戏中，蛇精的速度最快、初始武力值最高，成为大Boss的可能性最大。
某种程度上，蛇精与葫芦娃的第一次战斗极大影响了之后的战局：葫芦娃战斗力相近，第一场战斗的结局胜负各半数若蛇精胜利，在不断加成的作用下，妖怪们的胜率越来越大；若葫芦娃胜利，由于其他妖怪都很“弱鸡”，干掉蛇妖，基本可以锁定胜局。

### 移动设定  
- 寻找目标  
混战状态下，生物会自动寻找距离自己最近的敌人作为目标`FindTarget()`，以一定的速度向目标连续移动`Move(int x, int y)`。  
- 观察移动  
在生物移动过程中，仍在不断观察局面。一方面，确定自己的运动方向仍然指向最近的敌人；另一方面，警惕有无敌人进入攻击范围`WithinRange(Creature c)`，若有，则需要立刻发动攻击`Battle(Creature another)`


正是基于上述战斗及移动设定，本游戏中的生物对象的行为更为激进、混乱，与现实中失去理智的乱斗更为接近，所以与战斗相关的类北城为`ChaosLoader`


## 并发说明
本游戏中涉及到并发的主要有两大状态——混战状态和回放状态，分别对应类`ChaosLoader` 和 `ReplayLoader`。

####  `ChaosLoader`

每个生物都有对应的`ChaosLoader`线程,`Field`方法`StartPlay()`生成线程池，开启所有生物线程。  
临界区方法是`Battle(Creature another)`，战斗时，同时给战斗双方用`synchronized`加锁，以确保不会出现多方混战的情况。
此外，由于线程太多、对象变化过于频繁，在线程内部`Battle`之外的部分还要经常判定自身以及目标的生死，防止“尸体活动”的情况出现。
当发现自己死亡的时候，自身线程自动退出。此外，线程进行中，有寻找敌人的过程，当发现敌人都死光了，就可以将`state`置为`ended`,同时自身线程退出。其他存活线程接受到`state`的变化后，同样退出。此时，多线程并发的大混战终于结束了！

####  `ReplayLoader`
`ReplayLoader`是相对单一的线程。一个游戏中，在回放状态下只可能有一个`ReplayLoader`在运行。  
之所以将其设置为线程，是因为，  
(1) `Field`中的方法更接近静态，游戏回放更像是动态运行;  
(2) 读取时间记录，控制播放速度的代码用了Sleep，用线程控制速度更好；  
(3) 并且，回放过程中涉及一些异常处理（`MySavedFormatException`, `FileNotFoundException`等），有关状态切换与页面处理，单独分开，通过一个新的模块更加清晰。  


## 异常处理
异常处理主要集中在`ReplayLoader`中，这是一个变读取、边播放的
类,涉及了一些IO、格式相关的异常主要有:   
1. `FileNotFoundException`  
 抛出代码：    `BufferedReader br = field.LoadSave(file);`  
找不到指定要播放的游戏记录。
 
2.`IOException`  
抛出代码：   `line = br.readLine()`  
流读取异常

3.`InterruptedException`  
抛出代码：   `Thread.sleep()`  
处理sleep中可能发生的中断  

以上异常一旦发生，重放过程不可能再继续，所我将它们集中在一个处理Exception的catch块，与其他预测不到异常一起处理：  
即， 打印StackTrace + 对话框提示 + 线程终止

4.`NumberFormatException`  
抛出代码：   `Integer.parseInt(words[0])`等  
读取到的文件内容不是要求的形式  


5.`MySavedFormatIncorrectException`  
抛出代码：   
```		
throw new MySaveFormatException("Error Occurs on line " + counter +"  \""+ line +"\"");
```
自定义异常，读取到的文件内容不是要求的形式时抛出  

以上两种异常，都与读取文件内容有关。读取播放一段时间后，可能因为文件内部内容缺失或损坏，无法继续读取。异常处理方式是：
打印异常信息，及发生的文件位置（方便查看错误）  
游戏提示用户，可以重新开始，或在当前局面下开启混战模式。也就是说，终止线程，回到开始界面，或者开启新的混战线程。
